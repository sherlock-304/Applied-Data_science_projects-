# Import libraries here
import pandas as pd
import matplotlib.pyplot as plt
import os
import plotly.express as px
from dash import Input, Output, dcc, html
from IPython.display import VimeoVideo
from dash import Dash
from scipy.stats.mstats import trimmed_var
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.metrics import silhouette_score
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler
import seaborn as sns
import pandas as pd 
import plotly.express as px
import pickle #Old
from IPython.display import VimeoVideo #Old
from scipy.stats.mstats import trimmed_var 
from sklearn.cluster import KMeans 
from sklearn.decomposition import PCA
from sklearn.metrics import silhouette_score 
from sklearn.pipeline import make_pipeline 
from sklearn.preprocessing import StandardScaler
from sklearn.utils.validation import check_is_fitted
import warnings 

#Importing data into Dataframe
df = pd.read_csv("data/SCFP2019.csv.gz")

#Proportions of Business Owners
prop_biz_owners = df["HBUS"].mean()
print("proportion of business owners in df:", prop_biz_owners)

#
inccat_dict = {
    1: "0-20",
    2: "21-39.9",
    3: "40-59.9",
    4: "60-79.9",
    5: "80-89.9",
    6: "90-100",
}
df_inccat = (
    df["INCCAT"]
    .replace(inccat_dict)
    .groupby(df["HBUS"])
    .value_counts(normalize=True)
    .rename("frequency")
    .to_frame()
    .reset_index()
)


#Income Distribution of Business Owners
fig, ax = plt.subplots()


sns.barplot(
    data=df_inccat,
    x="INCCAT",
    y="frequency",
    hue="HBUS",
    order= inccat_dict.values(),
    ax=ax
)

# Set labels and title
ax.set_xlabel("Income Category")
ax.set_ylabel("Frequency (%)")
ax.set_title("Income Distribution: Business Owners vs. Non-Business Owners")

# Show plot
plt.show()

# Plot "HOUSES" vs "DEBT" with hue as business ownership
fig, ax = plt.subplots(figsize=(8, 5))

sns.scatterplot(
    data=df,
    x= "DEBT",
    y= "HOUSES",
    hue = "HBUS",
    palette= "deep",
    ax= ax
)
ax.set_xlabel("Household Debt")
ax.set_ylabel("Home Value"),
ax.set_title("Home Value vs. Household Debt");

#Fetching data of small business owners with income less than 5 miliion
mask = (df["HBUS"] == 1) & (df["INCOME"] < 5e5)
df_small_biz = df[mask] 

#Small Business Owners Age Distribution 
# Plot histogram of "AGE"
fig, ax = plt.subplots()
df_small_biz["AGE"].plot(
    kind="hist",
    ax=ax
)

# Add labels and title
ax.set_xlabel("Age")
ax.set_ylabel("Frequency (count)")
ax.set_title("Small Business Owners: Age Distribution")

plt.show()

# Calculate variance, get 10 largest features
top_ten_var = df_small_biz.var().sort_values().tail(10)

# Calculate trimmed variance
top_ten_trim_var = (
    df_small_biz.apply(trimmed_var)
    .sort_values()
    .tail(10)
)

top_ten_trim_var

fig = px.bar(
    top_ten_trim_var,
    x= top_ten_trim_var,
    y= top_ten_trim_var.index,
    orientation="h",
    title="Small Business Owners: High Variance Features"
)

# Update axis labels
fig.update_layout(
    xaxis_title="Trimmed Variance [$]",
    yaxis_title="Feature"
)

# Show plot
fig.show()

high_var_cols = top_ten_trim_var.tail(5).index.to_list()
high_var_cols

#Turning list into feature matrix
X = df_small_biz[high_var_cols]
print("X shape:", X.shape)
X.head()

#Building the model

n_clusters = range(2, 13)
inertia_errors = []
silhouette_scores = []

# Add `for` loop to train model and calculate inertia, silhouette score.
for k in n_clusters:
    #Build a model
    model = make_pipeline(
        StandardScaler(),
        KMeans(n_clusters= k,
              random_state= 42)
    )
    #Train the model
    model.fit(X)
    #Calculate inertia score
    inertia_errors.append(model.named_steps["kmeans"].inertia_)
    #Calculate Silhouette score
    silhouette_scores.append(
        silhouette_score(X, model.named_steps["kmeans"].labels_)
        
                        )

print("Inertia:", inertia_errors[:11])
print()
print("Silhouette Scores:", silhouette_scores[:3])

# Create line plot of `inertia_errors` vs `n_clusters`
fig = px.line(
        x= n_clusters, y = inertia_errors, title = "K-Means Model: Inertia vs Number of Clusters")
fig.update_layout(xaxis_title = "Number of Clusters",
                 yaxis_title = "Inertia"
)
fig.show()

# Create a line plot of `silhouette_scores` vs `n_clusters`
fig = px.line(
        x= n_clusters, y = silhouette_scores, title = "K-Means Model: Silhouette Score vs Number of Clusters")
fig.update_layout(xaxis_title = "Number of Clusters",
                 yaxis_title = "Silhouette Score")
fig.show()

#Making pipleline for model processing 
final_model = make_pipeline(
    StandardScaler(),
    KMeans(
    n_clusters= 3,
    random_state=42)
)

labels = final_model.named_steps["kmeans"].labels_
xgb =  X.groupby(labels).mean()
final_model.fit(X)

# Create side-by-side bar chart of `xgb`
fig = px.bar(
    data_frame= xgb,
    barmode = "group",
    title = "Small Business Owner Finances by Cluster" 
)
fig.update_layout(xaxis_title = "Cluster",
                 yaxis_title = "Value [$]")
fig.show()

# Instantiate transformer
pca = PCA(n_components=2, random_state=42)

# Transform `X`
X_t = pca.fit_transform(X)

# Put `X_t` into DataFrame
X_pca = pd.DataFrame(X_t, columns= ["PC1", "PC2"])

print("X_pca shape:", X_pca.shape)
X_pca.head()

# Create scatter plot of PCA-transformed data
fig = px.scatter(
    data_frame=X_pca,
    x="PC1",
    y="PC2",
    color=labels.astype(str),
    title="PCA Representation of Clusters"
)

# Update axis labels
fig.update_layout(
    xaxis_title="PC1",
    yaxis_title="PC2"
)

# Show plot
fig.show()

